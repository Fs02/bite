package main

import (
	"flag"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	dt = data{
		Pkg: "main",
		Var: "files",
	}
	output   = ""
	trimPath = ""
)

func main() {
	flag.StringVar(&dt.Pkg, "package", dt.Pkg, "`name` of the package to generate")
	flag.StringVar(&dt.Var, "var", dt.Var, "`name` of the variable to generate")
	flag.StringVar(&output, "output", output, "`filename` to write the output to")
	flag.StringVar(&trimPath, "trim", trimPath, "path `prefix` to remove from the resulting file path")
	flag.Parse()

	if output == "" {
		flag.PrintDefaults()
		log.Fatal("-output is required.")
	}

	paths := make(map[string]struct{})
	for _, g := range flag.Args() {
		fmt.Println(g)
		matches, err := filepath.Glob(g)
		if err != nil {
			log.Fatal(err)
		}
		for _, m := range matches {
			paths[m] = struct{}{}
		}
	}

	for path := range paths {
		path = strings.TrimPrefix(path, trimPath)
		dt.Paths = append(dt.Paths, path)
	}

	file, err := os.Create(output)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	err = tmpl.Execute(file, dt)
	if err != nil {
		log.Fatal(err)
	}
}

type data struct {
	Pkg   string
	Var   string
	Paths []string
}

func content(path string) (string, error) {
	content, err := ioutil.ReadFile(path)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%#v", content), nil
}

var tmpl *template.Template

func init() {
	tmpl = template.Must(template.New("file").Funcs(template.FuncMap{"content": content}).Parse(tmplString))
}

const tmplString = `// Package {{ .Pkg }} is generated by github.com/Fs02/bite
package {{ .Pkg }}

var {{ .Var }} = map[string][]byte{
	{{range $i, $path := .Paths }}"{{ $path }}": {{ content $path }},{{ end }}
}
`
